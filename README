adehovit

1. Known bugs:
    None that I am aware of.

2. Design details
    Trie is a consolidated prefix tree that consolidates at insert, and allows
    the user to insert whenever they want. It was intended to work with generic
    data, but the node class ended up being pretty generic to begin with. It
    also implements AbstractCollection, which means that it has an iterator.
    This was useful for testing.

3. Runtime optimizations
    Prefix's are consolidated at inserted. Children are stored in a constant
    hashmap. Bigram and frequency are also stored in hashmaps for constant
    access. Finding the exact word is done using the frequency hashmap, since
    the trie would be (a little) slower. Lastly, instead of returning all of
    the suggestions and then sorting, we maintain a list of the 5 best. This
    means that every word is compared to the current best 5, instead of being
    compared to every other word.

4. Special Tests
    Nothing super interesting but I added System Tests in /autocorrect.

5. How to run
    Just as specified. mvn package followed by ./run with all the variables
    (--led followed by an int) and as many files as you want
6. Design Questions:
    a) How would you change your frontend/backend code so that you could handle
    autocorrecting multiple input fields on the same page? Would you need to
    make any changes?

    I would just create an Instance of the Command class for each word, and
    retrieve the results for formatting. The gui is similarly easy, since it
    pases the entire line in which can then be iterated over to generate all of
    the corrections.

    b) Suppose some new letter, θ, has been introduced into the English
    alphabet. This letter can be appended to the end of any English word,
    to negate it. For example, badθ would mean "good". We are asking about the
    effects of this 1984-esque vocabularily enhanced universe on the size of
    your Trie. You will now need to store twice as many words in your trie as
    before. How many more nodes will you need to store in your trie? We are
    looking for you to support your answer with details about how your trie is
    implemented and what data it stores.

    I will need as many new nodes as there are new words. Every new word would
    be a child of the root word that it came of. For example, badθ would be
    one of the children of bad. No connector (nodes that don't represent words)
    would have a new child. Also, I could just change the node class to
    represent this new addition. Each word node would mean <root> and <root>θ.

7. Smart ranking
        My smart ranking attempted to address the issue of rank differently.
        Instead of making a choice based on unigram or bigram alone, I attempted
        to create a weighted system where various variables factor into whether
        or not a String is better than another. Additionally, I really wanted to
        use Levenshtein Distance as a method of ranking, but since I didn't want
        to calculate Lev Distance for every word we're considering, I only used
        it when it had already been calculated as part of the Lev Distance
        search.

8. Check style errors:

 Error	imports	ImportOrder	Wrong order for 'java.io.BufferedReader' import 20
 //Spent a lot of time trying to find the right order, and ultimately couldn't.
 //Imports are still organized and work
 Error	coding	InnerAssignment	Inner assignments should be avoided.	125
  //Keeps things more concise, which I like, and from my previous java experience
  it's seems pretty standard
 Error	coding	MagicNumber	'500' is a magic number.	211
 //This was provided code that I didn't want to change


 //Both of these are related to hashcoding, and were also InteliJ generated.
 Error	coding	MagicNumber	'31' is a magic number.	133
 Error	coding	MagicNumber	'31' is a magic number.	134

